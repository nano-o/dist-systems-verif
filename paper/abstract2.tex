\abstract{
  State-machine replication enables building reliable computing services on top
  of several unreliable hardware units. SMR is use in clusters of machines and
  will become increasingly important as the individual cores of many-core
  processors become more unreliable but more numerous.

    To achieve consistent performance, a distributed computing service must
    dynamically adapt to unpredictable crashes, communication failures, 
    shared resources availability, load and access patterns.
    Most existing algorithms are not adaptive: outside of their sweet spot, they have poor performance.
    We focus on State-Machine Replication (SMR) algorithms, a basic building block of reliable
    distributed computing.
    We present a framework that allows changing SMR algorithm on the fly while
    preserving the semantics of SMR. Once an SMR algorithm is cast into our
    framework and proved composable, it can be composed with any other
    composable SMR algorithm in any order.

    The key novelty of our framework is its practical applicability, having state
    of the art optimization and reconfiguration techniques built-in: tolerating k fault with k+1
    replicas using an external reconfiguration master, executing commutative commands 
    without synchronization, optimizing the execution of read-only commands,
    minimizing the size of crucial data structures. 

    Moreover, our framework allows a novel characterization of SMR algorithms in two categories corresponding to two abstract
    specifications that the algorithms refine. The two categories represent a
    fundamental three-dimensional trade-off relating resilience to crashes,
    resilience to contention, and processing latency. Cluster idea?


    We present a detailed, mechanically-proved formalization of our framework in
    Isabelle/HOL, and we show how several SMR algorithms fit into our framework.

    The framework is fully formalized and its main properties
    mechanically proven with Isabelle/HOL. The concrete
    algorithms we present are formalized in TLA+ and shown to
    fit in our framework using the TLC model-checker.
  }

