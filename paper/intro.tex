\section{Introduction}

The State-Machine Replication technique (abbreviated SMR) allows building
reliable computing services on top of unreliable hardware. The basic idea is
to replicate a service over several servers and enforce, using a distributed
protocol, that each server executes the same sequence of deterministic commands.
In this fashion, a command will produce the same effect on all replicas.
Therefore, if a replica crashes, clients of the service can be transparently redirected to
another replica and will have the illusion of accessing a centralized service at
all times. SMR is often formally specified using the Generalized Consensus
specification~\cite{Lamport05GeneralizeConsensus}, abbreviated GC\@.

Because SMR is part of the basic infrastructure supporting cloud computing,
improving the performance of SMR algorithms can result in performance gains,
cost reduction, or improved resilience (because SMR may be used where it was
too costly before) for many online services.

However, devising new SMR algorithms or optimizing existing ones for a
particular use-case is hard: today, more than two decades after the first SMR
algorithms~\cite{Lamport98ParttimeParliament,BirmanJoseph87ReliableCommunicationPresenceFailures,OkiLiskov88ViewstampedReplicationGeneralPrimaryCopy,DworkLynchStockmeyer84ConsensusPresencePartialSynchronyPreliminaryVersion}
were proposed, devising a new SMR algorithm can justify a publication in a top
conference~\cite{MoraruAndersenKaminsky13ThereIsMoreConsensusEgalitarianParliaments,OngaroOusterhout14SearchUnderstandableConsensusAlgorithm}.

The problem is that it is difficult to reuse existing algorithms and ideas
because SMR algorithms are not modular. When devising a new algorithm, any
analysis, test, or correctness proof has to be done again from scratch.

To simplify the task of devising new SMR algorithms we propose a framework for
devising reusable SMR modules. A module in our framework is an SMR algorithm
augmented with an \emph{abort interface} for aborting its execution and passing
the baton to another module and with a matching \emph{init interface} for taking
over the execution of an aborting module. Two modules are composed by passing
the outputs produced by the abort interface of the first module, called abort
values, as inputs to the init interface of the second module, called init values
in the context of the second module.

A module must satisfy a correctness condition that we call Composable
Generalized Consensus (abbreviated CGC). Any correct module is a safe
Generalized Consensus~\cite{Lamport05GeneralizeConsensus} algorithm, but the progress guarantees may vary between
modules: CGC only requires a module to make progress executing commands or to
abort its execution. CGC also relates the init values, learned values (learned values represent the local state-machine state of individual replicas), and abort values in order for our composition theorem to hold. 
Generalized Consensus is a specification of SMR algorithms that takes into account the commutativity relation among commands and can off important performance advantages in practice. 

The composition theorem enables incremental development of SMR algorithms
because it guarantees that any number of correct modules may be composed in
a sequence to form a correct SMR algorithm. Therefore, our framework allows
building \emph{dynamic SMR algorithms}, which dynamically change module when
the currently running module aborts, choosing the module best suited to the
current operating conditions. Thanks to the composition theorem, new modules can
be added to a dynamic SMR algorithm without modifying the existing modules and
with guaranteed correctness. Moreover, the relaxed progress requirements of CGC
enable a separation of concerns that simplifies optimizing SMR algorithms for
particular scenarios because there is no need to consider executing commands
under a situation outside the scenario: the module can just abort in this case.

In practice, we provide a TLA+ specification of CGC that the user of our framework can use to debug and prove new modules correct using the TLA$^+$ toolbox~\cite{TLATools}.
Moreover, we also provide two TLA+ specifications simplifying the development of modules based on Refined Quorum Systems~\cite{GuerraouiVukolic10RefinedQuorumSystems}. These two specifications both implement CGC and provide a skeleton for a user to build her own module. The two specifications demonstrate how to update the local state of a replica after gathering the states or the init values of a write quorum of replicas, and how to
produce an abort value after gathering the state of a read quorum of replicas. 
The two specifications use different combinations of sizes of read and write quorums, which affects the invariants that the replicas must maintain and, in consequence, the latency with which a command can be processed but the module.
Our two specifications abstract over how to disseminate the commands to the replicas (e.g.\ whether to use a leader as in Paxos, multiple leaders as in MultiCoordinatedPaxos, or whether to broadcast commands without using a leader as in Fast Paxos).
The user can therefore specify a concrete command dissemination procedure and then model-check that the obtained algorithm refines one of the two specifications.  
We demonstrate the practical use of our framework by presenting modules based on Paxos~\cite{Lamport98ParttimeParliament}, Fast Paxos\cite{Lamport06FastPaxos}, Chain Replication~\cite{RenesseSchneider04ChainReplicationSupportingHighThroughputAvailability}, a case of Vertical Paxos~\cite{LamportMalkhiZhou09VerticalPaxosPrimarybackupReplication}, and EPaxos~\cite{MoraruAndersenKaminsky13ThereIsMoreConsensusEgalitarianParliaments}
(TODO, but would be nice).

Compared to related work, described in \cref{sec:related}, our key contributions are the following.
\begin{itemize}
    \item We provide tool support for designing CGC modules in the form of two TLA+~\cite{Lamport02SpecifyingSystems} specifications simplifying the design and model-checking of SMR algorithms based on Quorum Systems~\cite{GuerraouiVukolic10RefinedQuorumSystems} and demonstrate their use by designing CGC modules inspired by Paxos, Fast Paxos, and Primary-Backup replication.
    \item Our framework is based on Generalized Consensus, a generalization of the consensus problem 
        that allows optimizing the execution of commuting commands, a common practical case.
\end{itemize}
These two contributions set this paper apart from related work, notably the Abstract framework~\cite{GuerraouiETAL10Next700BftProtocols} and the Speculative Linearizability framework~\cite{GuerraouiKuncakLosa12SpeculativeLinearizability}, both described in \cref{sec:related}.
Our TLA+ specifications can be found at \url{http://losa.fr/cgc}.
Moreover, we have also formalized the CGC correctness condition and proved the composition theorem in Isabelle/HOL\@, and the Isabelle theories are available at the same URL\@.
