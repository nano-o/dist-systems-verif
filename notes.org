* In Generalized Paxos, it is only required that at all times the set of learned values be compatible. We require that it from a chain.
What are the implications of this?
** None in practice it seems, as all of the algorithms guarantee the chain property.
* Why do we have the consistency property?
* Fast and safe rounds:
** Fast rounds have lower latency but tolerate less faults.
** Safe rounds have a higher latency but tolerate more faults.
* Vertical Paxos allows reconfiguration but not changing algorithm.
* Classification of algorithms:
** Best case latency
** Size of read quorums: number of faults that can be tolerated before reconfiguration.
** Number of crashes before deviation from optimal latency (in the 2f+1 case?).
* Benefits of generalized consensus: Fast algorithms only?
* Fast Paxos also combines two strategies, but without a clear isolation.
* Composition correctness: difficulty is showing that the abort and initialize actions simulate actions of the single-instance specification.
* Difference between Composable Generalized Paxos and Generalized Paxos:
** Uniform vs non-uniform interface
CGP has a uniform interface for rounds: regardless of the type of round, one switch value is enough to progress.
In contrast, changing round in Paxos or GP requires knowing the type of round (mainly determines the size of the Quorums to use but might get trickier
for algorithms with many optimization tricks).
** Can we skip rounds in CGP like in Paxos? 
One needs to make sure that the round has been stopped, but if there is at least one switch value in this round then it has been stopped.
So a process that wants to change round can trigger a round change. Similarly in Paxos, a new leader must bring acceptors in its round.
* Make a clear comparison with Classic Paxos and GP
** Generic round interface makes changing round a little bit slower: 
instead of having the leader query directly the acceptors of the previous round, the switchers must query the acceptors.
But, in fact, the new leader can be a switcher.
** What if two processes want to become leader? It is the switching policy which chooses the configuration of the next round, _not_ like in Vertical Paxos.

